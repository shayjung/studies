그래프
노드=버텍스
버텍스 사이의 간선: 엣지

방향 없는 그래프
- () 사용

방향 있는 그래프
- <> 사용

가중치 그래프

그래프 순회(Graph Traversal)
1. 깊이 우선 탐색

**무방향 그래프 인접 행렬**
엣지가 이어진 버텍스는 전부 1로 채운다. 이어지지 않은 칸은 0으로 채운다.

**방향 그래프 인접 행렬**
엣지가 도착점인 버텍스 칸만 1로 채우고 나머지는 0으로 채운다.

그래프 구현 코드
2차원 배열(리스트)을 생성

1. 정점 생성
class Graph():
    def __init__ (self, size):
        self.SIZE = size
        self.graph = [[0 for _ in range(size) for _ in range(size)]] // 중첩 for문으로 0으로 채워진 2차원 리스트 생성

G1 = Graph(4) // 4행 4열짜리 리스트 생성

2. 정점 연결 (엣지)
G1.graph[0][1] = 1
G1.graph[0][2] = 1
G1.graph[0][3] = 1

G1.graph[1][0] = 1
G1.graph[1][1] = 1

**무방향 그래프와 방향 그래프의 구현은 똑같음.**
무방향 그래프는 *시작과 끝 엣지를 모두 각각 1* 연결. (ex. [0][1], [1][0])
방향 그래프는 *시작과 끝 엣지만* 1 연결. (ex. [0][1])

그래프 개선
변수를 사용
a, b, c, d = 1, 2, 3, 4
G1.graph[a][b] = 1
G1.graph[a][c] = 1

행렬에 이름 라벨 붙여서 출력: 코드 9-15


깊이 우선 탐색 구현
**스택**을 사용하나 top을 사용하지 않고 간단하게 append와 pop 자체로 구현
코드 9-3

방문 기록 리스트를 만들어 버텍스를 방문할 때마다 기록 리스트와 스택 리스트에 append 한다.
방문한 적이 있는 버텍스면 pass하고 없는 버텍스면 next로 지정하고 current에 입력.
다음에 방문할 버텍스가 없을 경우 스택을 pop해서 이전 위치로 돌아옴.
다 돌아오면(순회를 마치면) 스택이 모두 비게 된다.

------

신장 트리(Spanning Tree)
: 그래프는 아니지만 그래프의 탐색 기법을 사용
1. 순환이 되지 않음
2. 간선의 합이 가장 작음

**가중치 그래프 구현** (크루스컬 알고리즘)
1. 엣지에 각각 가중치를 입력
2. 가중치를 가진 엣지들을 리스트에 넣기
3. 내림차순으로 엣지 정렬
    from operator import itemgetter
    edgeAry = sorted(edgeAry, key = itemgetter(0), reverse = True)
4. 중복 엣지 제거
5. 가중치 높은 엣지부터 제거
6. 제거하다가 다른 엣지를 찾을 수 없으면 복구시킨다


코드 9-5